function(data){
var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};
__p+='(function (global) {\r\n    function parseBigInt(str, r) {\r\n        return new BigInteger(str, r)\r\n    }\r\n\r\n    function linebrk(s, n) {\r\n        var ret = "";\r\n        var i = 0;\r\n        while (i + n < s.length) {\r\n            ret += s.substring(i, i + n) + "\\n";\r\n            i += n\r\n        }\r\n        return ret + s.substring(i, s.length)\r\n    }\r\n\r\n    function byte2Hex(b) {\r\n        if (b < 16) {\r\n            return "0" + b.toString(16)\r\n        } else {\r\n            return b.toString(16)\r\n        }\r\n    }\r\n\r\n    function pkcs1pad2PP(s, n) {\r\n        if (n < s.length + 11) {\r\n            console.log("Message too long for RSA");\r\n            return null\r\n        }\r\n        var ba = new Array();\r\n        var i = s.length - 1;\r\n        while (i >= 0 && n > 0) {\r\n            var c = s.charCodeAt(i--);\r\n            if (c < 128) {\r\n                ba[--n] = c\r\n            } else {\r\n                if ((c > 127) && (c < 2048)) {\r\n                    ba[--n] = (c & 63) | 128;\r\n                    ba[--n] = (c >> 6) | 192\r\n                } else {\r\n                    ba[--n] = (c & 63) | 128;\r\n                    ba[--n] = ((c >> 6) & 63) | 128;\r\n                    ba[--n] = (c >> 12) | 224\r\n                }\r\n            }\r\n        }\r\n        ba[--n] = 0;\r\n        var rng = new SecureRandom();\r\n        var x = new Array();\r\n        while (n > 2) {\r\n            x[0] = 0;\r\n            while (x[0] == 0) {\r\n                rng.nextBytes(x)\r\n            }\r\n            ba[--n] = x[0]\r\n        }\r\n        ba[--n] = 2;\r\n        ba[--n] = 0;\r\n        return new BigInteger(ba)\r\n    }\r\n\r\n    function RSAKeyPassPort() {\r\n        this.n = null;\r\n        this.e = 0;\r\n        this.d = null;\r\n        this.p = null;\r\n        this.q = null;\r\n        this.dmp1 = null;\r\n        this.dmq1 = null;\r\n        this.coeff = null\r\n    }\r\n\r\n    function RSASetPublicPP(N, E) {\r\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\r\n            this.n = parseBigInt(N, 16);\r\n            this.e = parseInt(E, 16)\r\n        } else {\r\n            alert("Invalid RSA public key")\r\n        }\r\n    }\r\n\r\n    function RSADoPublicPP(x) {\r\n        return x.modPowInt(this.e, this.n)\r\n    }\r\n\r\n    function RSAEncryptPP(text) {\r\n        var m = pkcs1pad2PP(text, (this.n.bitLength() + 7) >> 3);\r\n        if (m == null) {\r\n            return null\r\n        }\r\n        var c = this.doPublic(m);\r\n        if (c == null) {\r\n            return null\r\n        }\r\n        var h = c.toString(16);\r\n        if ((h.length & 1) == 0) {\r\n            return h\r\n        } else {\r\n            return "0" + h\r\n        }\r\n    }\r\n\r\n    RSAKeyPassPort.prototype.doPublic = RSADoPublicPP;\r\n    var rsaSwitch = "on";\r\n    RSAKeyPassPort.prototype.setPublic = RSASetPublicPP;\r\n    RSAKeyPassPort.prototype.encrypt = RSAEncryptPP;\r\n    var rng_state;\r\n    var rng_pool;\r\n    var rng_pptr;\r\n\r\n    function rng_seed_int(x) {\r\n        rng_pool[rng_pptr++] ^= x & 255;\r\n        rng_pool[rng_pptr++] ^= (x >> 8) & 255;\r\n        rng_pool[rng_pptr++] ^= (x >> 16) & 255;\r\n        rng_pool[rng_pptr++] ^= (x >> 24) & 255;\r\n        if (rng_pptr >= rng_psize) {\r\n            rng_pptr -= rng_psize\r\n        }\r\n    }\r\n\r\n    function rng_seed_time() {\r\n        rng_seed_int(new Date().getTime())\r\n    }\r\n\r\n    if (rng_pool == null) {\r\n        rng_pool = new Array();\r\n        rng_pptr = 0;\r\n        var t;\r\n        if (navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {\r\n            var z = window.crypto.random(32);\r\n            for (t = 0; t < z.length; ++t) {\r\n                rng_pool[rng_pptr++] = z.charCodeAt(t) & 255\r\n            }\r\n        }\r\n        while (rng_pptr < rng_psize) {\r\n            t = Math.floor(65536 * Math.random());\r\n            rng_pool[rng_pptr++] = t >>> 8;\r\n            rng_pool[rng_pptr++] = t & 255\r\n        }\r\n        rng_pptr = 0;\r\n        rng_seed_time()\r\n    }\r\n    function rng_get_byte() {\r\n        if (rng_state == null) {\r\n            rng_seed_time();\r\n            rng_state = prng_newstate();\r\n            rng_state.init(rng_pool);\r\n            for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {\r\n                rng_pool[rng_pptr] = 0\r\n            }\r\n            rng_pptr = 0\r\n        }\r\n        return rng_state.next()\r\n    }\r\n\r\n    function rng_get_bytes(ba) {\r\n        var i;\r\n        for (i = 0; i < ba.length; ++i) {\r\n            ba[i] = rng_get_byte()\r\n        }\r\n    }\r\n\r\n    function SecureRandom() {\r\n    }\r\n\r\n    SecureRandom.prototype.nextBytes = rng_get_bytes;\r\n    function Arcfour() {\r\n        this.i = 0;\r\n        this.j = 0;\r\n        this.S = new Array()\r\n    }\r\n\r\n    function ARC4init(key) {\r\n        var i, j, t;\r\n        for (i = 0; i < 256; ++i) {\r\n            this.S[i] = i\r\n        }\r\n        j = 0;\r\n        for (i = 0; i < 256; ++i) {\r\n            j = (j + this.S[i] + key[i % key.length]) & 255;\r\n            t = this.S[i];\r\n            this.S[i] = this.S[j];\r\n            this.S[j] = t\r\n        }\r\n        this.i = 0;\r\n        this.j = 0\r\n    }\r\n\r\n    function ARC4next() {\r\n        var t;\r\n        this.i = (this.i + 1) & 255;\r\n        this.j = (this.j + this.S[this.i]) & 255;\r\n        t = this.S[this.i];\r\n        this.S[this.i] = this.S[this.j];\r\n        this.S[this.j] = t;\r\n        return this.S[(t + this.S[this.i]) & 255]\r\n    }\r\n\r\n    Arcfour.prototype.init = ARC4init;\r\n    Arcfour.prototype.next = ARC4next;\r\n    function prng_newstate() {\r\n        return new Arcfour()\r\n    }\r\n\r\n    var rng_psize = 256;\r\n    var dbits;\r\n    var canary = 244837814094590;\r\n    var j_lm = ((canary & 16777215) == 15715070);\r\n\r\n    function BigInteger(a, b, c) {\r\n        if (a != null) {\r\n            if ("number" == typeof a) {\r\n                this.fromNumber(a, b, c)\r\n            } else {\r\n                if (b == null && "string" != typeof a) {\r\n                    this.fromString(a, 256)\r\n                } else {\r\n                    this.fromString(a, b)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function nbi() {\r\n        return new BigInteger(null)\r\n    }\r\n\r\n    function am1(i, x, w, j, c, n) {\r\n        while (--n >= 0) {\r\n            var v = x * this[i++] + w[j] + c;\r\n            c = Math.floor(v / 67108864);\r\n            w[j++] = v & 67108863\r\n        }\r\n        return c\r\n    }\r\n\r\n    function am2(i, x, w, j, c, n) {\r\n        var xl = x & 32767, xh = x >> 15;\r\n        while (--n >= 0) {\r\n            var l = this[i] & 32767;\r\n            var h = this[i++] >> 15;\r\n            var m = xh * l + h * xl;\r\n            l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);\r\n            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\r\n            w[j++] = l & 1073741823\r\n        }\r\n        return c\r\n    }\r\n\r\n    function am3(i, x, w, j, c, n) {\r\n        var xl = x & 16383, xh = x >> 14;\r\n        while (--n >= 0) {\r\n            var l = this[i] & 16383;\r\n            var h = this[i++] >> 14;\r\n            var m = xh * l + h * xl;\r\n            l = xl * l + ((m & 16383) << 14) + w[j] + c;\r\n            c = (l >> 28) + (m >> 14) + xh * h;\r\n            w[j++] = l & 268435455\r\n        }\r\n        return c\r\n    }\r\n\r\n    if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {\r\n        BigInteger.prototype.am = am2;\r\n        dbits = 30\r\n    } else {\r\n        if (j_lm && (navigator.appName != "Netscape")) {\r\n            BigInteger.prototype.am = am1;\r\n            dbits = 26\r\n        } else {\r\n            BigInteger.prototype.am = am3;\r\n            dbits = 28\r\n        }\r\n    }\r\n    BigInteger.prototype.DB = dbits;\r\n    BigInteger.prototype.DM = ((1 << dbits) - 1);\r\n    BigInteger.prototype.DV = (1 << dbits);\r\n    var BI_FP = 52;\r\n    BigInteger.prototype.FV = Math.pow(2, BI_FP);\r\n    BigInteger.prototype.F1 = BI_FP - dbits;\r\n    BigInteger.prototype.F2 = 2 * dbits - BI_FP;\r\n    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";\r\n    var BI_RC = new Array();\r\n    var rr, vv;\r\n    rr = "0".charCodeAt(0);\r\n    for (vv = 0; vv <= 9; ++vv) {\r\n        BI_RC[rr++] = vv\r\n    }\r\n    rr = "a".charCodeAt(0);\r\n    for (vv = 10; vv < 36; ++vv) {\r\n        BI_RC[rr++] = vv\r\n    }\r\n    rr = "A".charCodeAt(0);\r\n    for (vv = 10; vv < 36; ++vv) {\r\n        BI_RC[rr++] = vv\r\n    }\r\n    function int2char(n) {\r\n        return BI_RM.charAt(n)\r\n    }\r\n\r\n    function intAt(s, i) {\r\n        var c = BI_RC[s.charCodeAt(i)];\r\n        return (c == null) ? -1 : c\r\n    }\r\n\r\n    function bnpCopyTo(r) {\r\n        for (var i = this.t - 1; i >= 0; --i) {\r\n            r[i] = this[i]\r\n        }\r\n        r.t = this.t;\r\n        r.s = this.s\r\n    }\r\n\r\n    function bnpFromInt(x) {\r\n        this.t = 1;\r\n        this.s = (x < 0) ? -1 : 0;\r\n        if (x > 0) {\r\n            this[0] = x\r\n        } else {\r\n            if (x < -1) {\r\n                this[0] = x + DV\r\n            } else {\r\n                this.t = 0\r\n            }\r\n        }\r\n    }\r\n\r\n    function nbv(i) {\r\n        var r = nbi();\r\n        r.fromInt(i);\r\n        return r\r\n    }\r\n\r\n    function bnpFromString(s, b) {\r\n        var k;\r\n        if (b == 16) {\r\n            k = 4\r\n        } else {\r\n            if (b == 8) {\r\n                k = 3\r\n            } else {\r\n                if (b == 256) {\r\n                    k = 8\r\n                } else {\r\n                    if (b == 2) {\r\n                        k = 1\r\n                    } else {\r\n                        if (b == 32) {\r\n                            k = 5\r\n                        } else {\r\n                            if (b == 4) {\r\n                                k = 2\r\n                            } else {\r\n                                this.fromRadix(s, b);\r\n                                return\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.t = 0;\r\n        this.s = 0;\r\n        var i = s.length, mi = false, sh = 0;\r\n        while (--i >= 0) {\r\n            var x = (k == 8) ? s[i] & 255 : intAt(s, i);\r\n            if (x < 0) {\r\n                if (s.charAt(i) == "-") {\r\n                    mi = true\r\n                }\r\n                continue\r\n            }\r\n            mi = false;\r\n            if (sh == 0) {\r\n                this[this.t++] = x\r\n            } else {\r\n                if (sh + k > this.DB) {\r\n                    this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\r\n                    this[this.t++] = (x >> (this.DB - sh))\r\n                } else {\r\n                    this[this.t - 1] |= x << sh\r\n                }\r\n            }\r\n            sh += k;\r\n            if (sh >= this.DB) {\r\n                sh -= this.DB\r\n            }\r\n        }\r\n        if (k == 8 && (s[0] & 128) != 0) {\r\n            this.s = -1;\r\n            if (sh > 0) {\r\n                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh\r\n            }\r\n        }\r\n        this.clamp();\r\n        if (mi) {\r\n            BigInteger.ZERO.subTo(this, this)\r\n        }\r\n    }\r\n\r\n    function bnpClamp() {\r\n        var c = this.s & this.DM;\r\n        while (this.t > 0 && this[this.t - 1] == c) {\r\n            --this.t\r\n        }\r\n    }\r\n\r\n    function bnToString(b) {\r\n        if (this.s < 0) {\r\n            return "-" + this.negate().toString(b)\r\n        }\r\n        var k;\r\n        if (b == 16) {\r\n            k = 4\r\n        } else {\r\n            if (b == 8) {\r\n                k = 3\r\n            } else {\r\n                if (b == 2) {\r\n                    k = 1\r\n                } else {\r\n                    if (b == 32) {\r\n                        k = 5\r\n                    } else {\r\n                        if (b == 4) {\r\n                            k = 2\r\n                        } else {\r\n                            return this.toRadix(b)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;\r\n        var p = this.DB - (i * this.DB) % k;\r\n        if (i-- > 0) {\r\n            if (p < this.DB && (d = this[i] >> p) > 0) {\r\n                m = true;\r\n                r = int2char(d)\r\n            }\r\n            while (i >= 0) {\r\n                if (p < k) {\r\n                    d = (this[i] & ((1 << p) - 1)) << (k - p);\r\n                    d |= this[--i] >> (p += this.DB - k)\r\n                } else {\r\n                    d = (this[i] >> (p -= k)) & km;\r\n                    if (p <= 0) {\r\n                        p += this.DB;\r\n                        --i\r\n                    }\r\n                }\r\n                if (d > 0) {\r\n                    m = true\r\n                }\r\n                if (m) {\r\n                    r += int2char(d)\r\n                }\r\n            }\r\n        }\r\n        return m ? r : "0"\r\n    }\r\n\r\n    function bnNegate() {\r\n        var r = nbi();\r\n        BigInteger.ZERO.subTo(this, r);\r\n        return r\r\n    }\r\n\r\n    function bnAbs() {\r\n        return (this.s < 0) ? this.negate() : this\r\n    }\r\n\r\n    function bnCompareTo(a) {\r\n        var r = this.s - a.s;\r\n        if (r != 0) {\r\n            return r\r\n        }\r\n        var i = this.t;\r\n        r = i - a.t;\r\n        if (r != 0) {\r\n            return (this.s < 0) ? -r : r\r\n        }\r\n        while (--i >= 0) {\r\n            if ((r = this[i] - a[i]) != 0) {\r\n                return r\r\n            }\r\n        }\r\n        return 0\r\n    }\r\n\r\n    function nbits(x) {\r\n        var r = 1, t;\r\n        if ((t = x >>> 16) != 0) {\r\n            x = t;\r\n            r += 16\r\n        }\r\n        if ((t = x >> 8) != 0) {\r\n            x = t;\r\n            r += 8\r\n        }\r\n        if ((t = x >> 4) != 0) {\r\n            x = t;\r\n            r += 4\r\n        }\r\n        if ((t = x >> 2) != 0) {\r\n            x = t;\r\n            r += 2\r\n        }\r\n        if ((t = x >> 1) != 0) {\r\n            x = t;\r\n            r += 1\r\n        }\r\n        return r\r\n    }\r\n\r\n    function bnBitLength() {\r\n        if (this.t <= 0) {\r\n            return 0\r\n        }\r\n        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))\r\n    }\r\n\r\n    function bnpDLShiftTo(n, r) {\r\n        var i;\r\n        for (i = this.t - 1; i >= 0; --i) {\r\n            r[i + n] = this[i]\r\n        }\r\n        for (i = n - 1; i >= 0; --i) {\r\n            r[i] = 0\r\n        }\r\n        r.t = this.t + n;\r\n        r.s = this.s\r\n    }\r\n\r\n    function bnpDRShiftTo(n, r) {\r\n        for (var i = n; i < this.t; ++i) {\r\n            r[i - n] = this[i]\r\n        }\r\n        r.t = Math.max(this.t - n, 0);\r\n        r.s = this.s\r\n    }\r\n\r\n    function bnpLShiftTo(n, r) {\r\n        var bs = n % this.DB;\r\n        var cbs = this.DB - bs;\r\n        var bm = (1 << cbs) - 1;\r\n        var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;\r\n        for (i = this.t - 1; i >= 0; --i) {\r\n            r[i + ds + 1] = (this[i] >> cbs) | c;\r\n            c = (this[i] & bm) << bs\r\n        }\r\n        for (i = ds - 1; i >= 0; --i) {\r\n            r[i] = 0\r\n        }\r\n        r[ds] = c;\r\n        r.t = this.t + ds + 1;\r\n        r.s = this.s;\r\n        r.clamp()\r\n    }\r\n\r\n    function bnpRShiftTo(n, r) {\r\n        r.s = this.s;\r\n        var ds = Math.floor(n / this.DB);\r\n        if (ds >= this.t) {\r\n            r.t = 0;\r\n            return\r\n        }\r\n        var bs = n % this.DB;\r\n        var cbs = this.DB - bs;\r\n        var bm = (1 << bs) - 1;\r\n        r[0] = this[ds] >> bs;\r\n        for (var i = ds + 1; i < this.t; ++i) {\r\n            r[i - ds - 1] |= (this[i] & bm) << cbs;\r\n            r[i - ds] = this[i] >> bs\r\n        }\r\n        if (bs > 0) {\r\n            r[this.t - ds - 1] |= (this.s & bm) << cbs\r\n        }\r\n        r.t = this.t - ds;\r\n        r.clamp()\r\n    }\r\n\r\n    function bnpSubTo(a, r) {\r\n        var i = 0, c = 0, m = Math.min(a.t, this.t);\r\n        while (i < m) {\r\n            c += this[i] - a[i];\r\n            r[i++] = c & this.DM;\r\n            c >>= this.DB\r\n        }\r\n        if (a.t < this.t) {\r\n            c -= a.s;\r\n            while (i < this.t) {\r\n                c += this[i];\r\n                r[i++] = c & this.DM;\r\n                c >>= this.DB\r\n            }\r\n            c += this.s\r\n        } else {\r\n            c += this.s;\r\n            while (i < a.t) {\r\n                c -= a[i];\r\n                r[i++] = c & this.DM;\r\n                c >>= this.DB\r\n            }\r\n            c -= a.s\r\n        }\r\n        r.s = (c < 0) ? -1 : 0;\r\n        if (c < -1) {\r\n            r[i++] = this.DV + c\r\n        } else {\r\n            if (c > 0) {\r\n                r[i++] = c\r\n            }\r\n        }\r\n        r.t = i;\r\n        r.clamp()\r\n    }\r\n\r\n    function bnpMultiplyTo(a, r) {\r\n        var x = this.abs(), y = a.abs();\r\n        var i = x.t;\r\n        r.t = i + y.t;\r\n        while (--i >= 0) {\r\n            r[i] = 0\r\n        }\r\n        for (i = 0; i < y.t; ++i) {\r\n            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t)\r\n        }\r\n        r.s = 0;\r\n        r.clamp();\r\n        if (this.s != a.s) {\r\n            BigInteger.ZERO.subTo(r, r)\r\n        }\r\n    }\r\n\r\n    function bnpSquareTo(r) {\r\n        var x = this.abs();\r\n        var i = r.t = 2 * x.t;\r\n        while (--i >= 0) {\r\n            r[i] = 0\r\n        }\r\n        for (i = 0; i < x.t - 1; ++i) {\r\n            var c = x.am(i, x[i], r, 2 * i, 0, 1);\r\n            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\r\n                r[i + x.t] -= x.DV;\r\n                r[i + x.t + 1] = 1\r\n            }\r\n        }\r\n        if (r.t > 0) {\r\n            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1)\r\n        }\r\n        r.s = 0;\r\n        r.clamp()\r\n    }\r\n\r\n    function bnpDivRemTo(m, q, r) {\r\n        var pm = m.abs();\r\n        if (pm.t <= 0) {\r\n            return\r\n        }\r\n        var pt = this.abs();\r\n        if (pt.t < pm.t) {\r\n            if (q != null) {\r\n                q.fromInt(0)\r\n            }\r\n            if (r != null) {\r\n                this.copyTo(r)\r\n            }\r\n            return\r\n        }\r\n        if (r == null) {\r\n            r = nbi()\r\n        }\r\n        var y = nbi(), ts = this.s, ms = m.s;\r\n        var nsh = this.DB - nbits(pm[pm.t - 1]);\r\n        if (nsh > 0) {\r\n            pm.lShiftTo(nsh, y);\r\n            pt.lShiftTo(nsh, r)\r\n        } else {\r\n            pm.copyTo(y);\r\n            pt.copyTo(r)\r\n        }\r\n        var ys = y.t;\r\n        var y0 = y[ys - 1];\r\n        if (y0 == 0) {\r\n            return\r\n        }\r\n        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\r\n        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;\r\n        var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;\r\n        y.dlShiftTo(j, t);\r\n        if (r.compareTo(t) >= 0) {\r\n            r[r.t++] = 1;\r\n            r.subTo(t, r)\r\n        }\r\n        BigInteger.ONE.dlShiftTo(ys, t);\r\n        t.subTo(y, y);\r\n        while (y.t < ys) {\r\n            y[y.t++] = 0\r\n        }\r\n        while (--j >= 0) {\r\n            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\r\n            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\r\n                y.dlShiftTo(j, t);\r\n                r.subTo(t, r);\r\n                while (r[i] < --qd) {\r\n                    r.subTo(t, r)\r\n                }\r\n            }\r\n        }\r\n        if (q != null) {\r\n            r.drShiftTo(ys, q);\r\n            if (ts != ms) {\r\n                BigInteger.ZERO.subTo(q, q)\r\n            }\r\n        }\r\n        r.t = ys;\r\n        r.clamp();\r\n        if (nsh > 0) {\r\n            r.rShiftTo(nsh, r)\r\n        }\r\n        if (ts < 0) {\r\n            BigInteger.ZERO.subTo(r, r)\r\n        }\r\n    }\r\n\r\n    function bnMod(a) {\r\n        var r = nbi();\r\n        this.abs().divRemTo(a, null, r);\r\n        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {\r\n            a.subTo(r, r)\r\n        }\r\n        return r\r\n    }\r\n\r\n    function Classic(m) {\r\n        this.m = m\r\n    }\r\n\r\n    function cConvert(x) {\r\n        if (x.s < 0 || x.compareTo(this.m) >= 0) {\r\n            return x.mod(this.m)\r\n        } else {\r\n            return x\r\n        }\r\n    }\r\n\r\n    function cRevert(x) {\r\n        return x\r\n    }\r\n\r\n    function cReduce(x) {\r\n        x.divRemTo(this.m, null, x)\r\n    }\r\n\r\n    function cMulTo(x, y, r) {\r\n        x.multiplyTo(y, r);\r\n        this.reduce(r)\r\n    }\r\n\r\n    function cSqrTo(x, r) {\r\n        x.squareTo(r);\r\n        this.reduce(r)\r\n    }\r\n\r\n    Classic.prototype.convert = cConvert;\r\n    Classic.prototype.revert = cRevert;\r\n    Classic.prototype.reduce = cReduce;\r\n    Classic.prototype.mulTo = cMulTo;\r\n    Classic.prototype.sqrTo = cSqrTo;\r\n    function bnpInvDigit() {\r\n        if (this.t < 1) {\r\n            return 0\r\n        }\r\n        var x = this[0];\r\n        if ((x & 1) == 0) {\r\n            return 0\r\n        }\r\n        var y = x & 3;\r\n        y = (y * (2 - (x & 15) * y)) & 15;\r\n        y = (y * (2 - (x & 255) * y)) & 255;\r\n        y = (y * (2 - (((x & 65535) * y) & 65535))) & 65535;\r\n        y = (y * (2 - x * y % this.DV)) % this.DV;\r\n        return (y > 0) ? this.DV - y : -y\r\n    }\r\n\r\n    function Montgomery(m) {\r\n        this.m = m;\r\n        this.mp = m.invDigit();\r\n        this.mpl = this.mp & 32767;\r\n        this.mph = this.mp >> 15;\r\n        this.um = (1 << (m.DB - 15)) - 1;\r\n        this.mt2 = 2 * m.t\r\n    }\r\n\r\n    function montConvert(x) {\r\n        var r = nbi();\r\n        x.abs().dlShiftTo(this.m.t, r);\r\n        r.divRemTo(this.m, null, r);\r\n        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {\r\n            this.m.subTo(r, r)\r\n        }\r\n        return r\r\n    }\r\n\r\n    function montRevert(x) {\r\n        var r = nbi();\r\n        x.copyTo(r);\r\n        this.reduce(r);\r\n        return r\r\n    }\r\n\r\n    function montReduce(x) {\r\n        while (x.t <= this.mt2) {\r\n            x[x.t++] = 0\r\n        }\r\n        for (var i = 0; i < this.m.t; ++i) {\r\n            var j = x[i] & 32767;\r\n            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\r\n            j = i + this.m.t;\r\n            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\r\n            while (x[j] >= x.DV) {\r\n                x[j] -= x.DV;\r\n                x[++j]++\r\n            }\r\n        }\r\n        x.clamp();\r\n        x.drShiftTo(this.m.t, x);\r\n        if (x.compareTo(this.m) >= 0) {\r\n            x.subTo(this.m, x)\r\n        }\r\n    }\r\n\r\n    function montSqrTo(x, r) {\r\n        x.squareTo(r);\r\n        this.reduce(r)\r\n    }\r\n\r\n    function montMulTo(x, y, r) {\r\n        x.multiplyTo(y, r);\r\n        this.reduce(r)\r\n    }\r\n\r\n    Montgomery.prototype.convert = montConvert;\r\n    Montgomery.prototype.revert = montRevert;\r\n    Montgomery.prototype.reduce = montReduce;\r\n    Montgomery.prototype.mulTo = montMulTo;\r\n    Montgomery.prototype.sqrTo = montSqrTo;\r\n    function bnpIsEven() {\r\n        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0\r\n    }\r\n\r\n    function bnpExp(e, z) {\r\n        if (e > 4294967295 || e < 1) {\r\n            return BigInteger.ONE\r\n        }\r\n        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\r\n        g.copyTo(r);\r\n        while (--i >= 0) {\r\n            z.sqrTo(r, r2);\r\n            if ((e & (1 << i)) > 0) {\r\n                z.mulTo(r2, g, r)\r\n            } else {\r\n                var t = r;\r\n                r = r2;\r\n                r2 = t\r\n            }\r\n        }\r\n        return z.revert(r)\r\n    }\r\n\r\n    function bnModPowInt(e, m) {\r\n        var z;\r\n        if (e < 256 || m.isEven()) {\r\n            z = new Classic(m)\r\n        } else {\r\n            z = new Montgomery(m)\r\n        }\r\n        return this.exp(e, z)\r\n    }\r\n\r\n    BigInteger.prototype.copyTo = bnpCopyTo;\r\n    BigInteger.prototype.fromInt = bnpFromInt;\r\n    BigInteger.prototype.fromString = bnpFromString;\r\n    BigInteger.prototype.clamp = bnpClamp;\r\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\r\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\r\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\r\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\r\n    BigInteger.prototype.subTo = bnpSubTo;\r\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\r\n    BigInteger.prototype.squareTo = bnpSquareTo;\r\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\r\n    BigInteger.prototype.invDigit = bnpInvDigit;\r\n    BigInteger.prototype.isEven = bnpIsEven;\r\n    BigInteger.prototype.exp = bnpExp;\r\n    BigInteger.prototype.toString = bnToString;\r\n    BigInteger.prototype.negate = bnNegate;\r\n    BigInteger.prototype.abs = bnAbs;\r\n    BigInteger.prototype.compareTo = bnCompareTo;\r\n    BigInteger.prototype.bitLength = bnBitLength;\r\n    BigInteger.prototype.mod = bnMod;\r\n    BigInteger.prototype.modPowInt = bnModPowInt;\r\n    BigInteger.ZERO = nbv(0);\r\n    BigInteger.ONE = nbv(1);\r\n\r\n    var passportPubKey = \'\';\r\n    var passportPubKeyIndex = \'00\';\r\n    var RSAEncrypt = function (input) {\r\n        if (!passportPubKey) {\r\n            return input;\r\n        }\r\n        var rsa = new RSAKeyPassPort();\r\n        rsa.setPublic(passportPubKey, "10001");\r\n        var res = rsa.encrypt(input);\r\n        if (res == null) {\r\n            return input;\r\n        }\r\n        return res\r\n    };\r\n\r\n    var Ck = function () {\r\n        var uniqueInstance;\r\n        var bd, html;\r\n        var touchStartTime;\r\n        var touchEndTime;\r\n        var pressTime;\r\n        var initTime;\r\n        var touchX;\r\n        var touchY;\r\n        var clinetH;\r\n        var clinetW;\r\n        var isStartScroll;\r\n        var scrollLastY;\r\n        var scrollStartY;\r\n        var scrollStartTime;\r\n        var scrollLastTime;\r\n        var scrollTotalTime;\r\n        var scrollDirection;\r\n        var scrollNum;\r\n        var scrollTotalChange;\r\n        var validDirection;\r\n        var imTimeSign;\r\n        var scrollBoundary = 10;\r\n        var numReg = /\\d+/;\r\n\r\n        function constructor() {\r\n            /**\r\n             * 机型判断\r\n             */\r\n            bd = document.body;\r\n            html = document.documentElement;\r\n            clinetH = html.clientHeight;\r\n            clinetW = html.clientWidth;\r\n            touchStartTime = -1;\r\n            touchEndTime = -1;\r\n            pressTime = -1;\r\n            touchX = -1;\r\n            touchY = -1;\r\n            scrollLastY = -1;\r\n            scrollStartY = -1;\r\n            scrollStartTime = -1;\r\n            scrollLastTime = -1;\r\n            scrollTotalTime = -1;\r\n            scrollDirection = \'none\';\r\n            scrollNum = -1;\r\n            scrollTotalChange = -1;\r\n            validDirection = \'none\';\r\n            initTime = new Date().getTime();\r\n            addListener();\r\n            return {\r\n                getCkValue: getCkValue,\r\n                clearCount: clearCount\r\n            };\r\n        }\r\n\r\n        /**\r\n         * 事件监听\r\n         */\r\n        function addListener() {\r\n            bd.addEventListener(\'touchstart\', onTouchStart, true);\r\n            bd.addEventListener(\'touchend\', onTouchEnd, true);\r\n            /**\r\n             * 如果是iOS系统通过 touchmove 模拟触发 scroll 事件\r\n             */\r\n            bd.addEventListener(\'touchmove\', onTouchMove, true);\r\n            window.addEventListener(\'scroll\', onScrollEvent, true);\r\n        }\r\n\r\n        /**\r\n         * 在触摸按下的时候,滚轮计算处理和记录按下时间和坐标\r\n         * @param  {Event} event\r\n         */\r\n        function onTouchStart(event) {\r\n            var touch = event.touches.item(0);\r\n            touchX = touch.pageX;\r\n            touchY = touch.pageY;\r\n            countScrollOnTouchStart();\r\n            touchStartTime = getEventTime(event);\r\n        }\r\n\r\n        function onTouchEnd(event) {\r\n            touchEndTime = getEventTime(event);\r\n            pressTime = touchEndTime - touchStartTime;\r\n        }\r\n\r\n        function onTouchMove(event) {\r\n            triggerScrollEventForIphone(event);\r\n        }\r\n\r\n        /**\r\n         * 为ios模拟scroll事件持续触发\r\n         * @param  {evnt} event\r\n         */\r\n        function triggerScrollEventForIphone(event) {\r\n            onScrollEvent(event);\r\n        }\r\n\r\n        function onScrollEvent(event) {\r\n            /**\r\n             * 标记开始滚动和开始坐标\r\n             */\r\n            if (!isStartScroll) {\r\n                isStartScroll = true;\r\n                scrollStartY = window.scrollY;\r\n            }\r\n\r\n            var nowScrollY = window.scrollY;\r\n            var scrollValue = Math.abs(nowScrollY - scrollLastY);\r\n            var nowDirection = getScrollDirection(scrollLastY, nowScrollY) || scrollDirection;\r\n\r\n            if (isValidScroll(scrollValue, nowDirection)) {\r\n                scrollLastTime = getEventTime(event);\r\n                if (validDirection === \'none\') {\r\n                    validDirection = scrollDirection;\r\n                    scrollStartTime = getEventTime(event);\r\n                }\r\n                if (validDirection !== scrollDirection) {\r\n                    scrollCount();\r\n                    scrollStartTime = getEventTime(event);\r\n                    validDirection = scrollDirection;\r\n                }\r\n            }\r\n\r\n            /**\r\n             * 记录下次使用值\r\n             */\r\n            scrollLastY = nowScrollY;\r\n        }\r\n\r\n        /**\r\n         * 以一次touchstart事件作为上一次完整scroll的结束，并计数\r\n         */\r\n        function countScrollOnTouchStart() {\r\n            if (isStartScroll && validDirection !== \'none\') {\r\n                scrollCount();\r\n                scrollTotalChange = 0;\r\n                isStartScroll = false;\r\n                scrollDirection = \'none\';\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 是否是一次有效的滚动\r\n         * @param {int} scroll 滚动距离.\r\n         * @param {string} nowDirection 滚动方向.\r\n         * @return {boolen}\r\n         */\r\n        function isValidScroll(scrollValue, nowDirection) {\r\n            if (scrollDirection === \'none\') {\r\n                scrollDirection = nowDirection;\r\n            }\r\n\r\n            if (nowDirection !== scrollDirection) {\r\n                scrollDirection = nowDirection;\r\n                scrollTotalChange = 0;\r\n            } else {\r\n                scrollTotalChange += scrollValue;\r\n            }\r\n            return scrollTotalChange > scrollBoundary;\r\n        }\r\n\r\n        /**\r\n         * 获取滚动方向\r\n         * @param  {int} startY 开始滚动坐标Y.\r\n         * @param  {int} nowY 当前滚动坐标Y.\r\n         * @return {string} \'up\' or \'down\' 如果nowY 和 startY 相等，就返回false.\r\n         */\r\n        function getScrollDirection(startY, nowY) {\r\n            if (nowY > startY) {\r\n                return \'up\';\r\n            } else if (nowY < startY) {\r\n                return \'down\';\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * 滚动计数\r\n         * 记录滚动次数和滚动时间\r\n         */\r\n        function scrollCount() {\r\n            scrollNum === -1 && scrollNum++;\r\n            scrollNum++;\r\n            scrollTotalTime += scrollLastTime - scrollStartTime;\r\n            validDirection = \'none\';\r\n        }\r\n\r\n        /*\r\n         * 获取ck的键值\r\n         * 形如\r\n         * 0:value1,1:value2,2:value3\r\n         0 touchX x\r\n         1 touchY y\r\n         2 pressTime x\r\n         3 scrollNum y\r\n         4 version\r\n         5 clinetH\r\n         6 clinetW\r\n         7 eventTime 初始化ck到获取ck的时间间隔，单位 100毫秒\r\n         8 isPreventByMask 点击误点蒙板区域的状态  0 或 1\r\n         * */\r\n        function getCkValue(anchor, e) {\r\n            e = window.event || e;\r\n            var eventTime = Math.floor((new Date().getTime() - initTime) / 100);\r\n            if (touchX === -1 || touchY === -1) {\r\n                touchX = e.clientX || e.pageX;\r\n                touchY = e.clientY || e.pageY;\r\n            }\r\n            var keyList = {\r\n                \'2\': Math.round(pressTime) || 0,\r\n                \'3\': scrollNum,\r\n                \'4\': 1,\r\n                \'5\': clinetH,\r\n                \'6\': clinetW,\r\n                \'7\': eventTime\r\n            };\r\n            var value = [\'0:\' + (Math.ceil(touchX) || 0), \'1:\' + (Math.ceil(touchY) || 0)];\r\n            for (var i in keyList) {\r\n                if (keyList[i] > -1) {\r\n                    value.push(i + \':\' + keyList[i]);\r\n                }\r\n            }\r\n\r\n            (window.extraCK || []).forEach(function (n) {\r\n                n && value.push(n(touchX, touchY, anchor));\r\n            });\r\n            value = value.join(\',\');\r\n            return value;\r\n        }\r\n\r\n        function clearCount() {\r\n            scrollNum = 0;\r\n            scrollTotalTime = 0;\r\n        }\r\n\r\n        /**\r\n         * 如果时间为0，产生date.time来替代，主要为了firefox 写的，Firefox的event.timeStamp都为0;\r\n         */\r\n        function getEventTime(event) {\r\n            if (event.timeStamp !== 0) {\r\n                return event.timeStamp;\r\n            } else {\r\n                var date = new Date();\r\n                return date.getTime();\r\n            }\r\n        }\r\n\r\n        return {\r\n            getInstance: function () {\r\n                if (!uniqueInstance) {\r\n                    uniqueInstance = constructor();\r\n                }\r\n                return uniqueInstance;\r\n            }\r\n        };\r\n    };\r\n    var ckInstance;\r\n    /*\r\n     * 暴露rsa加密，防止侦查，使用jesgoo的名字\r\n     * */\r\n    global.jesgoo = {\r\n        setPubKey: function (key, keyIndex) {\r\n            passportPubKey = key;\r\n            keyIndex >= 0 && (passportPubKeyIndex = keyIndex);\r\n        },\r\n        RSAEncrypt: RSAEncrypt,\r\n        triggerCK: function () {\r\n            return global.jesgoo.ckInstance = ckInstance = Ck().getInstance();\r\n        },\r\n        getCk: function (anchor) {\r\n            if (!ckInstance) return \'\';\r\n            var ckValue = ckInstance.getCkValue(anchor);\r\n            global.jesgoo.ckValue = ckValue;\r\n            global.jesgoo.ckValueEncrypt = passportPubKeyIndex + RSAEncrypt(ckValue);\r\n            return global.jesgoo.ckValueEncrypt;\r\n        }\r\n    };\r\n})(this);';
return __p;
}